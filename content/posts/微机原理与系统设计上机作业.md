---
title: 微机原理与系统设计上机作业
date: 2017-05-23T19:46:04+08:00
tags: ["微机原理"]
categories: ["技术"]
---

# 实验一 EMU8086使用及指令系统熟悉

## 实验要求

1. 熟悉并掌握EMU8086 汇编语言调试环境；
2. 学习8086的指令系统，输入简单的指令，观察各寄存器、内存相关单元以及处理器标志位的变化（数据传送类指令，算数运算类指令，逻辑运算类指令，标志处理和CPU控制类指令，移位和循环移位类指令，处理器控制类指令等，要求每类指令至少一个用例。具体用例自行设计，可参考教材用例）；
3. 学习汇编语言程序设计的基本步骤和方法；
4. 学会使用EMU8086 debug调试程序；
5. 编写一个简单的程序：将“This is my first ASM program-姓名（汉语拼音各人的姓名）”放在DS=1000H，BX=0000H开始的存储器单元中，然后将该内容搬移到BX=0100H开始的单元中，最后将该字符串通过DOS功能调用显示在屏幕上。

## 实验目的

1. 学习EMU8086仿真开发环境的使用，理解和掌握汇编语言编程的基本步骤；
2. 熟悉8086指令系统；
3. 熟悉变量、常量及伪指令的使用；
4. 熟悉内存单元的存储结构，字符串的处理以及简单的编程。

## 实验内容

### 一、书本指令用例调试

传送指令：mov（直接寻址）

![img](clip_image002.jpg)

xchg：交换指令（直接寻址）

![img](clip_image004.jpg)

地址传送指令：lea

![img](clip_image006.jpg)

入栈出栈操作：Push/pop

![img](clip_image008.jpg)

加法操作：add

![img](clip_image010.jpg)

减法操作：sub

![img](clip_image012.jpg)

综合程序1

![img](clip_image014.jpg)

乘法操作：div

![img](clip_image016.jpg)

and指令

![img](clip_image018.jpg)

or指令

![img](clip_image020.jpg)

not指令

![img](clip_image022.jpg)

异或（xor）指令

![img](clip_image024.jpg)

移位指令：sal

![img](clip_image026.jpg)

 

**移位指令：****sar**

![img](clip_image028.jpg)

串操作指令：movsb

![img](clip_image030.jpg)

jmp指令

![img](clip_image032.jpg)

循环操作指令

![img](clip_image034.jpg)

### 二、编写一个简单的程序

将“This is my first ASM program-姓名（汉语拼音各人的姓名）”放在DS=1000H，BX=0000H开始的存储器单元中，然后将该内容搬移到BX=0100H开始的单元中，最后将该字符串通过DOS功能调用显示在屏幕上。

#### 代码

```assembly
name 'aa'

org 00h

assume cs:code ds:data

data segment
msg db 'T',7h,'h',7h,'i',7h,'s',7h,' ',7h,'m',7h,'y',7h,' ',7h,'f',7h,'i',7h,'r',7h,'s',7h,'t',7h,' ',7h,'A',7h,'S',7h,'M',7h,' ',7h,'p',7h,'r',7h,'o',7h,'g',7h,'r',7h,'a',7h,'m',7h,'-',7h,'W',7h,'a',7h,'n',7h,'g',7h,'R',7h,'u',7h,'i',7h
data ends

code segment 

start: 

  mov ax,1000h
  mov es,ax
  mov ax,data
  mov ds,ax
  mov di,00h
  mov si,00h
  mov cx,72
  rep movsb

  mov ax,0b800h
  mov es,ax
  mov di,0a00h
  mov si,00h
  mov cx,72
  rep movsb

  mov ax,1000h
  mov es,ax
  mov si,00h
  mov di,0100h
  mov cx,72
  rep movsb  

mov ax,4c00h

int 21h 

code ends 

end start

ret
```

![img](clip_image036.jpg)

运用数据段和代码段，先将数据写入1000:0000，往屏幕输出后再将数据搬入1000:0100

### 三、感受感想

本学期新接触微机原理这门课程，刚开始接触汇编，感觉进入了新的领域，对其中的思想和思维方式还没有，在这次上机实验实际操作和作业过程中，巩固了老师上课所讲的要点，也学着用会变得角度去思考问题和设计思路，同时在自己的许多改正中了解了出现的错误所代表的内在性质，进一步加强了自己的理解。不过现在对于一些汇编指令还不够熟悉，需要经常查书，自己也会在基础知识这方面加强，写出更好看更实用的代码。

*当时的自己hhhh*

# 实验二 顺序、分支、循环、子程序设计

## 实验要求

1. 教材P74例1。m=6,n=4,w=7。结果Q也放在内存中。
2. 教材P75例3。
3. 从键盘上输入1个数，判断其奇偶性，如果是奇数，屏幕上显示”It is odd”，否则显示”It is even”。
4. 从键盘上输入N个字符（N<16），求这N个字符中’A’的个数，并将’A’的个数显示在屏幕上。
5. 已知BUF1中有N1个按从小到大的顺序排列的互不相等的无符号数，BUF2中有N2个从小到大的顺序排列的互不相等的无符号数。编写程序将BUF1和BUF2中的数合并到BUF3中，使在BUF3中存放的数互不相等且按从小到大的顺序排列。
6. 需要预习报告。

## 实验目的

学习顺序、分支、循环结构以及子程序的编程设计。

## 实验内容

### 1.源码

```assembly
; You may customize this and other start-up templates; 
; The location of this template is c:\emu8086\inc\0_com_template.txt

org 100h

data db 6,4,7          ;定义数字
xor ax,ax
lea si,data
mov al,[si]            ;储存数字
mov bl,[si+1]
mul bl                 ;乘法运算
sub al,[si+2]          ;加法运算
mov [si+3],ax          ;储存结果

mov ax,4c00h
int 21h                ;程序结束
```

![img](clip_image002-1585749590672.jpg)

结果依次存放在内存代码段，6,4,7均为需进行运算的数，11为最后结果。

### 2.源码

```assembly

; You may customize this and other start-up templates; 
; The location of this template is c:\emu8086\inc\0_com_template.txt

org 100h

data1 db 40 dup(90)                ;为简便输入，假设前40人90分，后40人59分
data2 db 40 dup(59)
buffer db 4 dup(0)

start:
    xor dx,dx
    xor bx,bx
    mov cx,80
    lea si,data1
    lea di,buffer
goon:
    mov al,[si]
    cmp al,90
    jc next3
    inc dh
    jmp stor
next3:
    cmp al,70
    jc next5
    inc dl
    jmp stor
next5:
    cmp al,60
    jc next7
    inc bh
    jmp stor
next7:
    inc bl
stor:
    inc si
    loop goon
    mov [di],dh
    mov [di+1},dl
    mov [di+2],bh
    mov [di+3],bl
mov ax,4c00h
int 21h

ret
```

![img](clip_image004-1585749590673.jpg)

最后在bl、dh、内存中都能找到成绩归类后的计数。

### 3.源码

```assembly
data1 segment
    msgo db "It is odd",0ah,0dh,"$"
    msge db "It is even",0ah,0dh,"$"
    num db 20
data1 ends 

code1 segment
    assume cs:coda1 ds:data1
start:
    mov ax,data1
    mov ds,ax
    lea dx,num    
    
    mov ah,0ah                  ;输入数字到缓冲区
    int 21h
    
    xor ax,ax
    mov al,[num+1]
    mov si,ax
    add si,1ah      
    shr [si],1
    
    jb odd
    
    lea dx,msge
    mov ah,09h
    int 21h
    jmp over
    
    odd:
        lea dx,msgo
        mov ah,09h
        int 21h
                
    over:
        mov ah,4ch
        int 21h
code1 ends
end start
```

![img](clip_image006-1585749590673.jpg)

![img](clip_image008-1585749590673.jpg)

### 4.源码

```assembly
data1 segment
    msg db 16
data1 ends

code1 segment
    assume cs:code1 ds:data1
start:
    mov ax,data1
    mov ds,ax
    
    mov ah,0ah                     ;输入字符串到缓冲区
    int 21h
    
    mov cl,[msg+1]
    
    lea si,msg
    add si,2h
    again:
        cmp [si],65
        jz addd
        inc si
        dec cx
        cmp cx,0
        jz pr
        jnz again
    addd:
        inc si
        inc dx                     ;计数
        cmp cx,0
        dec cx
        jnz again
    pr:
        add dl,30h                 ;技术结果存在dl里
        mov ah,02h                 ;输出dl里面的技术结果
        int 21h
              
        mov ah,4ch
        int 21h

code1 ends
end start
```

![img](clip_image010-1585749590673.jpg)

### 5.源码

```assembly
data1 segment
    buf1 db 05h,31h,33h,34h,36h,37h		;buf1和buf2里面的第一个数字为要排列数字的个数
    buf2 db 04h,32h,35h,37h,39h		    ;设除了第一个数字以外为有效数字，则第一个数字为有效数字的个数
    buf3 db 09h dup(0)					;buf3的第一个数字为需要buf1和buf2有效数字之和
data1 ends

stack1 segment
    sta db 10h                           ;用到栈，即设置栈
stack1 ends

code1 segment
    assume cs:code1 ds:data1 ss:stack1
    
    start:
        mov ax,data1
        mov ds,ax
        mov es,ax                         ;设置ds、es
        mov ax,stack1                     ;设置栈段
        mov ss,ax
        
        lea si,buf1+1
        lea di,buf2+1                     ;设置偏移地址
        
        mov ch,buf1
        mov cl,buf2
        
        a1:
            cmp ch,0
            jz ers
            cmp cl,0
            jz yis                        ;ch和cl里分别保存了buf1和buf2的有效数字的个数
            
            mov ah,[si]
            mov al,[di]
            cmp ah,al
            js xiao                       ;进行比较，根据不同结果跳转到不同执行过程
            jz deng
            jns da
            
            xor dx,dx
            xor bl,bl
            xiao:                         ; 前者<后者
                mov dl,ah
                push dx
                inc bl
                inc si
                dec ch
                jmp a1
            
            deng:                          ;前者=后者
                mov dl,ah
                push dx
                inc bl
                inc si
                inc di
                dec ch
                dec cl
                jmp a1
            da:                            ;前者>后者
                mov dl,al
                push dx
                inc bl
                inc di
                dec cl
                jmp a1
            
        yis:                               ;buf1有剩余时
            mov dl,ch
            push dx
            pop cx
            xor dx,dx
            again1:
                mov dl,[si]
                push dx
                inc bl
                inc si
                loop again1
            jmp rev
                
        ers:                                ;buf2有剩余时
            xor dx,dx
            again2:
                mov dl,[di]
                push dx 
                inc bl
                inc di
                loop again2
            jmp rev
        rev:                                ;数据压入栈后倒叙输出，并输出到指定内存位置（即buf3的位置）
            lea si,buf3
            add si,bx
            dec si
            again: 
                cmp sp,0h
                jz over
                pop dx
                mov [si],dl
                dec si
                loop again    
                        
        over:
            mov ah,4ch
            int 21h
code1 ends
end start
```

程序开始时的内存状态：

![img](clip_image012-1585749590673.jpg)

运行后的栈内情况：

![img](clip_image014-1585749590673.jpg)

运行后的内存情况（排序结果紧随其后）

![img](clip_image016-1585749590673.jpg)

# 实验三 综合程序设计

## 实验要求

编写程序实现下列5项功能，通过从键盘输入1～5进行菜单式选择：

1. 按数字键“1”，完成将字符串中的小写字母变换成大写字母。用户输入由英文大小写字母或数字0～9组成的字符串（以回车结束），变换后按下列格式在屏幕上显示：

<原字符串>例如：abcdgyt0092

<新字符串> ABCDGYT0092

按任一键重做；按Esc键返回主菜单。

2. 按数字键“2”，完成在字符串中找最大值。用户输入由英文大小写字母或数字0～9 组成的字符串（以回车结束），找出其中数字字符的最大值，按下列格式在屏幕上显示：

<原字符串> The maximum number is <最大值>．

按任一键重做；按Esc键返回主菜单。

3. 按数字键“3”，完成输入数据组的排序。用户输入一组（小于50个）十进制数值（小于255），中间以逗号分隔，回车表示输入结束。按递增方式进行排序，并将结果按下列格式在屏幕上显示：

<原数值串>

<新数值串>

按任一键重做；按Esc键返回主菜单。

4. 按数字键“4”，完成系统时间的显示。首先提示用户对时，即改变系统的定时器HH：MM：SS（以冒号间隔，回车结束），然后在屏幕的右上角实时显示出时间：HH：MM：SS。

按任一键重新对时；按Esc键返回主菜单。

5. 按数字键“5”，结束程序的运行，返回系统。

请提前做好上级预习工作。

## 实验目的

学习掌握DOS常用功能的调用方法，综合进行程序设计。增强和提高汇编语言程序设计的能力，掌握模块化程序的设计方法。

## 实验内容

### 1.源码

```assembly
data1 segment
    org 0
    info11 db "Please press keys:$"
    info12 db "translated to:$"
          
    info21 db "Please input the string:$"
    info22 db "The max is:$"
        
    info41 db "Please correct the time:$"
        
    in1 db 16
    out1 db 16
    
    in2 db 16
    out2 db 1
    
    in31 db 50
    in311 db 49 dup(0)
    in32 db 255 
    
    time4 db "00:00:00$"
         
    str1 db "Please switch the function number",0ah,0dh,"1.lower to upper",0ah,0dh,"2.find the max",0ah,0dh,"3.sort the number",0ah,0dh,"4.display the time",0ah,0dh,"5.exit the system",0ah,0dh,"$"         
data1 ends

stack1 segment
    stack dw 100
stack1 ends

code1 segment
    assume cs:code1 ds:data1
    
    start:
        mov ax,data1
        mov ds,ax

    menu:
        call clear
        
        lea dx,str1
        mov ah,09h
        int 21h
        
        mov ah,01h
        int 21h    
        cmp al,31h
        jz fun1 
        cmp al,32h
        jz fun2         
        cmp al,33h
        jz fun3         
        cmp al,34h
        jz fun4           
        cmp al,35h
        jz over
        
    fun1:
        call clear         ;clear the screen
        
        call fun11
        mov ah,0h
        int 16h
        cmp ah,01h
        jz menu
        jnz fun1
         
             
    fun2:
        call clear
         
        call fun22 
        mov ah,0h
        int 16h
        cmp ah,01h
        jz menu
        jnz fun2
   
    fun3:
        call clear
        
        call fun33 
        mov ah,0h
        int 16h
        cmp ah,01h
        jz menu
        jnz fun3
            
    fun4:
        call clear
        
        call fun44
        mov ah,0h
        int 16h
        cmp ah,01h
        jz menu
        jnz fun4
                                
    fun11 proc near    
        lea dx,info11
        mov ah,09h
        int 21h          ;display "Press..."
        
        lea dx,in1
        mov ah,0ch
        mov al,0ah
        int 21h          ;input the string
        
        lea si,in1
        inc si
        
        mov cl,[si]
        inc cl
        again11:          ;loop of check
            dec cl
            cmp cl,0h
            jz output1
            inc si
            cmp [si],61h
            jc again11
            cmp [si],7ah
            ja again11
            sub [si],20h
            jmp again11
            
         output1:         ;output the result
            call sl       ;set the location
                   
            lea dx,info12
            mov ah,09h
            int 21h
            mov [si+1],24h
            lea dx,in1
            add dx,2h
            mov ah,09h
            int 21h     
         ret
    fun11 endp
    
    fun22 proc near
        lea dx,info21
        mov ah,09h
        int 21h           ;display "Please input the string"
        
        lea dx,in2
        mov ah,0ch
        mov al,0ah
        int 21h           ;input the string
         
        xor cx,cx 
        lea si,in2
        inc si
        mov cl,[si]
        inc cl
        xor bx,bx
        again2:
            dec cl 
            cmp cl,0h
            jz output2
            inc si
            cmp [si],bl
            jc again2
            mov bl,[si]
            jmp again2
        
        output2:
            call sl
            
            lea dx,info22
            mov ah,09h
            int 21h
            
            lea si,out2
            mov [si],bl
            mov [si+1],24h
            lea dx,out2
            mov ah,09h
            int 21h       
    ret
    fun22 endp
    
    fun33 proc near
    so_s: 
        mov ah, 0aH  
        lea si, in32
        mov dx, si
        lea di, in31
        int 21H
        inc si
        mov ds:[di], 0 
        mov cx, ds:[si]
        and cx, 00FFH
        mov bh, 0 
        mov bl, 1
        mov bp, 0 
        mov dl, 0
        mov ax, 0
    so_1:
        inc bp
        inc bh
        mov dh,ds:[si+bp]   
        cmp dh, ','
        jz  so_2 
        inc bh
        cmp cx,1
        jz so_2 
        dec bh
        jmp so_3
    so_2:
        add bl, 1 
        cmp bh, bl
        jz  st_1
        add bl, 1
        cmp bh, bl       
        jz  st_2
        add bl, 1
        cmp bh, bl
        jz  st_3 
        jmp so_3
    st_1:
        sub bl, 1
        push bx 
        push si
        mov bh, 0
        add si, bx
        mov al, ds:[si]
        sub al, 30H
        pop si
        pop bx
        jmp st_4
    st_2:
        sub bl, 2
        push bx 
        push si
        mov bh, 0 
        add si, bx
        mov al, ds:[si]
        sub al, 30H 
        mov dl, 10
        mul dl
        add al, ds:[si+1]
        sub al, 30H  
        pop si
        pop bx
        jmp st_4
    st_3:
        sub bl, 3 
        push bx
        push si
        mov bh, 0
        add si, bx
        mov al, ds:[si]
        sub al, 30H
        mov dl, 100
        mul dl
        mov bh, al
        mov al, ds:[si+1]
        sub al, 30H
        mov dl, 10
        mul dl
        add bh, al
        add bh, ds:[si+2]
        sub bh, 30H
        mov al, bh 
        pop si
        pop bx
        jmp st_4
    st_4:
        mov bl, bh
        inc bl  
        inc dl
        push bp
        inc ds:[di]
        mov bp, ds:[di] 
        and bp, 00FFH
        mov ds:[bp+di], al
        pop bp
    so_3:
        loop so_1
        push dx
        push si
        push cx
        push ax
        push bp
        push bx
        call bubble
        pop bx 
        pop bp
        pop ax
        pop cx
        pop si
        pop dx   
        lea dx, in31
        mov si, dx 
        lea dx, in32
        mov di, dx
        mov bl, 10
        mov cx, ds:[si]
        and cx, 00FFH 
        inc di
        mov bp, 0
    so_4:
        inc bp
        mov ah, 0H
        mov al, ds:[si+bp]
        cmp al, 99
        ja so_5
        cmp al, 9
        ja so_6
        jmp so_7
    so_5:
        div bl
        mov dh, ah
        mov ah, 00H
        div bl 
        add al, 30H
        mov ds:[di+1], al
        add ah, 30H
        mov ds:[di+2], ah
        add dh, 30H
        mov ds:[di+3], dh
        mov ds:[di+4], ','
        add di, 4 
        jmp so_8  
    so_6:
        div bl 
        add al, 30H
        mov ds:[di+1], al
        add ah, 30H 
        mov ds:[di+2], ah
        mov ds:[di+3], ','
        add di, 3
        jmp so_8
    so_7:
        add al,30H
        mov ds:[di+1], al
        mov ds:[di+2], ','
        add di, 2
    so_8:
        loop so_4
        mov ds:[di+1], '$'
        mov ah, 03H  
        mov bh, 0H
        int 10H
        add dh, 01H
        mov dl, 0
        mov ah, 02H
        int 10H
        lea dx, in32
        inc dx
        inc dx
        mov ah, 09H
        int 21H      
    ret    
    fun33 endp
 
    bubble proc near
        lea dx, in31
        mov si, dx
        mov cx, ds:[si]
        and cx, 00FFH 
        inc si 
        mov bp, 0FFFFH
        mov ah, 0 
        mov al, 0
    bu_1:
        inc bp
        mov ah, ds:[si+bp]
        mov bh, ah
        mov dx, bp
        push cx
        push bp
        dec cx
    bu_3:
        inc bp
        mov al, ds:[si+bp] 
        cmp cx, 0
        jz bu_6
        cmp al, ah 
        jna bu_4
        jmp bu_5
    bu_4:
        mov ah, al
        mov dx, bp 
    bu_5:
        loop bu_3
    bu_6:
        pop bp
        pop cx
        mov ds:[si+bp], ah
        push bp
        mov bp, dx
        mov ds:[si+bp], bh
        pop bp
        loop bu_1    
    ret
    bubble endp
    
    fun44 proc near
        lea dx,info41
        mov ah,09h
        int 21h
        
        mov ah,2ch
        int 21h
        
        xor ax,ax
        xor bx,bx
        mov al,ch
        lea si,time4
        mov bl,0ah
        mov al,ch
        div bl
        mov [si],al
        add [si],30h
        inc si
        mov [si],ah
        add [si],30h
        add si,2h
        
        xor ax,ax
        mov al,cl
        div bl
        mov [si],al
        add [si],30h
        inc si
        mov [si],ah
        add [si],30h
        add si,2h
        
        xor ax,ax
        mov al,dh
        div bl
        mov [si],al
        add [si],30h
        inc si
        mov [si],ah
        add [si],30h
        add si,2h           
        
        mov ah,02h
        mov bh,0h
        mov dh,00h
        mov dl,48h     
        int 10h 
        
        lea dx,time4
        mov ah,09h
        int 21h 
    ret
    fun44 endp
    
    clear proc near
        mov ah,0h
        mov al,3h
        mov bl,0
        int 10h
        ret 
    clear endp 
    
    sl proc near
        mov ah,02h
        mov bh,0h
        mov dh,01h
        mov dl,0h     
        int 10h
    ret
    sl endp 
              
    over:
        mov ah,4ch
        int 21h
code1 ends
end start
```

## 实验结果

### 开始的菜单界面

![img](clip_image002-1585753062049.jpg)

### 小写转大写

![img](clip_image004-1585753062050.jpg)

### 找到ASCII码值最大的

![img](clip_image006-1585753062051.jpg)

### 排序

![img](clip_image008-1585753062051.jpg)

### 同步时间

![img](clip_image010-1585753062051.jpg)

### 结束

![img](clip_image012-1585753062056.jpg)

# 实验四 软硬件综合设计

## 实验要求

1. 安装并学习PROTEUS集成开发仿真平台；

2. 使用PROTEUS完成基于8086最小系统的两块8X8 LED游动字符显示屏的软硬件仿真设计。显示内容：本人姓名+学号（英文或汉字均可，显示字模自行设计）

## 实验目的

综合8086/8088CPU总线技术、存储器扩展、输入输出、微机系统常用芯片以及汇编语言编程等内容，综合检验课程学习掌握状况。

## 实验内容

### proteus仿真电路图**

![img](clip_image002-1585753322496.jpg)

### 所用器件

![img](clip_image004-1585753322497.jpg)

### 结果截图

显示“518”

![img](clip_image006-1585753322499.jpg)

### 源码

```assembly
data1 segment
    data0 db 0ffh,0ffh,01h,0ffh,0ffh,    0ffh,61h,06dh,0dh,0ffh,    0ffh,0ffh,01h,0ffh,0ffh,    0ffh,01h,06dh,01h,0ffh,   0ffh,01h,07dh,01h,0ffh,    0ffh,0ffh,01h,0ffh,0ffh,   0ffh,0ffh,01h,0ffh,0ffh,     0ffh,01h,07dh,01h,0ffh,  0ffh,01h,07dh,01h,0ffh,   0ffh,61h,06dh,01h,0ffh,  0ffh,0fdh,0fdh,01h,0ffh,          0fbh,0efh,0bfh,0efh,0bfh,0efh,0fbh,     0ffh,0c3h,0dbh,0dbh,0c3h,0bfh,0ffh,     0ffh,0c3h,0fbh,0fbh,0c3h,0ffh,0ffh,     0ffh,0ffh,047h,057h,007h,0ffh,0ffh,     0ffh,0f7h,08fh,0f7h,0f7h,0ffh,0ffh,     0ffh,087h,0bfh,0bfh,087h,0ffh,0ffh,     0ffh,0ffh,08bh,0ffh,0ffh,0ffh,0ffh 
data1 ends                     ;define the data that will be displayed

stack1 segment
    db 10 dup(0)
stack1 ends

code1 segment
    assume cs:code1,ds:data1,ss:stack1
    start:
        mov ax,data1
        mov ds,ax            
        mov bx,offset data0
        mov ds:[100h],02h
         
         
        s1:
            mov cx,0ffh
        s2:
            mov ds:[102h],cx
            mov bp,bx
            mov cx,08h
            mov al,1h
            again1:
                mov dx,0000h
                mov ah,[bp]
                inc bp
                out dx,ax  
                mul ds:[100h]
                loop again1 
                   
        mov cx,08h 
        mov al,1h
        
        again2:
            mov dx,0004h
            mov ah,[bp]
            inc bp
            out dx,ax  
            mul ds:[100h]
            loop again2 
        mov ax,00h
        out dx,ax
        mov cx,ds:[102h]
        loop s2
        inc bx
        jmp s1
        
code1 ends
end start
```